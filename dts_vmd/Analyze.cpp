
#include "Analyze.h"
#include "Nfunction.h"
#include "Vec3D.h"
#include "RNG.h"
#include "GenerateCNTCells.h"
#include "Curvature.h"
#include "Energy.h"
#include "LinkFlipMC.h"
#include "WritevtuFiles.h"
#include "Restart.h"
#include "BTSFile.h"
#include "Traj_XXX.h"
#include "CoupleToWallPotential.h"
#include "ActiveTwoStateInclusion.h"
#include "CreateMashBluePrint.h"
#include "Surface_Mosaicing.h"
/*
#include "ActiveTwoStateInclusion.h"
*/
/*
 Weria Pezeshkian (weria.pezeshkian@gmail.com)
 Copyright (c) Weria Pezeshkian
 MC simulation class, runs mc simulation if it is defined in the input file.
 */
Analyze::Analyze(State *pState)
{
    
    int iter = 2;
    int ini=pState->m_Initial_Step;      // initial step for the Simulation; usually zero
    int final=pState->m_Final_Step;      // final step for the Simulation
    Nfunction f;
    
    
    std::string SURF_XTC = pState->m_GeneralOutputFilename+".xtc";
    XDRFILE *W_SURF_XTC=xdrfile_open(SURF_XTC.c_str(),  "w");
    
    for (int i = ini;i<final;i++)
    {
        std::string file = pState->m_TopologyFile + "/"+pState->m_GeneralOutputFilename+f.Int_to_String(i)+".tsi";
        
        CreateMashBluePrint BluePrint;
        MeshBluePrint meshblueprint = BluePrint.MashBluePrintFromInput_Top(pState->m_InputFileName,file);
        MESH          tmesh;
        *(pState->m_pMesh) = tmesh;
        (pState->m_pMesh)->GenerateMesh(meshblueprint);
        Vec3D *pBox = (pState->m_pMesh)->m_pBox;
        Vec3D Box = *(pBox);
        
        UpdateGeometry((pState->m_pMesh), pBox);
        
        
        
        std::vector <Surface_Mosaicing> Vmos;
        
        MESH          *ptmesh = (pState->m_pMesh);

        
        for (int j=0;j<iter;j++)
        {
            Surface_Mosaicing  MOS("Type1",false);
            Vmos.push_back(MOS);
        }

        for (int j=0;j<iter;j++)
        {
            // Here will cause error when
            (Vmos.at(j)).PerformMosaicing(ptmesh);
            ptmesh = (Vmos.at(j)).m_pMesh;
        }
        
        std::vector<vertex*> pV = ptmesh->m_pActiveV;

        std::cout<<pV.size()<<"\n";
        GreatePro(pV);
        std::cout<<pV.size()<<"\n";

        if(i==ini)
        {
            // write gro file
            std::string gfile = pState->m_GeneralOutputFilename+".gro";
            WriteGro(pV,gfile,Box);
        }
        // write xtc
        
        
        matrix box;
        float t = i*1000;
        float p = 330;
        box[0][0]=(*pBox)(0); box[0][1]=0; box[0][2]=0;
        box[1][1]=(*pBox)(1); box[1][0]=0; box[1][2]=0;
        box[2][2]=(*pBox)(2); box[2][0]=0; box[2][1]=0;
        Write_SURF_XTC_Frame(pV, W_SURF_XTC,i,t,box,p);
    }
    

    
}
Analyze::~Analyze()
{
}
void Analyze::Write_SURF_XTC_Frame(std::vector<vertex*> pV, XDRFILE * fout,int &step,float &time,matrix &box,float & prec)
{

    int N=pV.size();
    rvec* xnew = new rvec[N];
  //  Tensor2 R = RotMat();
    int i=0;
   for (std::vector<vertex*>::iterator it = pV.begin() ; it != pV.end(); ++it)
    {
    
            xnew[i][0]=(*it)->GetVXPos();
            xnew[i][1]=(*it)->GetVYPos();
            xnew[i][2]=(*it)->GetVZPos();
    
    i++;
    }
    write_xtc(fout,N,step,time,box,xnew,prec);
}
void Analyze::WriteGro(std::vector<vertex*> pV,std::string filename, Vec3D Box)
{
    
    Nfunction f;
    double resize = 1;

    FILE *fgro;
    fgro = fopen(filename.c_str(), "w");

     const char* Title="generated by DTS";
     int Size=pV.size();
     fprintf(fgro,  "%s\n",Title);
     fprintf(fgro, "%5d\n",Size);
     int i=0;
    
    for (std::vector<vertex*>::iterator it = pV.begin() ; it != pV.end(); ++it)
    {
        double x=(*it)->GetVXPos();
        double y=(*it)->GetVYPos();
        double z=(*it)->GetVZPos();

        std::string type;
        if((*it)->VertexOwnInclusion()==false)
        {
            type = "C";
        }
        else
        {
            inclusion* inc = (*it)->GetInclusion();
            type = "O";
        }
        const char* B=type.c_str();
        const char* A="Ver";
        int resid=0;
        
        fprintf(fgro, "%5d%5s%5s%5d%8.3f%8.3f%8.3f%8.4f%8.4f%8.4f\n",i%20000,A,B,i%20000,x/resize,y/resize,z/resize,0.0,0.0,0.0 );
        i++;
    }
   fprintf(fgro,  "%10.5f%10.5f%10.5f%10.5f%10.5f%10.5f%10.5f%10.5f%10.5f\n",Box(0)/resize,Box(1)/resize,Box(2)/resize,0.0,0.0,0.0,0.0,0.0,0.0 );
   fclose(fgro);
    
    
}
void  Analyze::UpdateGeometry(MESH *pmesh, Vec3D *pBox)
{
    Curvature CurvatureCalculations;
    for (std::vector<triangle *>::iterator it = (pmesh->m_pActiveT).begin() ; it != (pmesh->m_pActiveT).end(); ++it)
    {
    (*it)->UpdateNormal_Area(pBox);
    }
    
    //===== Prepare links:  normal vector and shape operator
    for (std::vector<links *>::iterator it = (pmesh->m_pHL).begin() ; it != (pmesh->m_pHL).end(); ++it)
    {
            (*it)->UpdateNormal();
            (*it)->UpdateShapeOperator(pBox);
    }
    //======= Prepare vertex:  area and normal vector and curvature of surface vertices not the edge one
    for (std::vector<vertex *>::iterator it = (pmesh->m_pSurfV).begin() ; it != (pmesh->m_pSurfV).end(); ++it)
        CurvatureCalculations.SurfVertexCurvature(*it);
    //====== edge links should be updated
    for (std::vector<links *>::iterator it = (pmesh->m_pEdgeL).begin() ; it != (pmesh->m_pEdgeL).end(); ++it)
            (*it)->UpdateEdgeVector(pBox);
    for (std::vector<vertex *>::iterator it = (pmesh->m_pEdgeV).begin() ; it != (pmesh->m_pEdgeV).end(); ++it)
        CurvatureCalculations.EdgeVertexCurvature(*it);
}
void  Analyze::GreatePro(std::vector<vertex*> &pV)
{
    m_MoreV.clear();
    int N=5;
    double R=0.1;
    double T=2*acos(-1)/double(N);
    int j=pV.size();
    for (std::vector<vertex *>::iterator it = pV.begin() ; it != pV.end(); ++it)
    {
        if((*it)->VertexOwnInclusion()==true)
        {
            (*it)->UpdateOwnInclusion(false);
            double x=(*it)->GetVXPos();
            double y=(*it)->GetVYPos();
            double z=(*it)->GetVZPos();
            Vec3D Pos(x,y,z);
            Vec3D Norm = (*it)->GetNormalVector();
            Norm=Norm*R;
            Tensor2  M = (*it)->GetL2GTransferMatrix();
            Vec3D L(R,0,0);
            Vec3D newL(0,0,0);

            for (int i=0;i<N;i++)
            {
                L(0)=R*cos(i*T);
                L(1)=R*sin(i*T);
                
                newL =Pos+Norm+M*L;
                vertex v(j,newL(0),newL(1),newL(2));
                v.UpdateOwnInclusion(true);
                m_MoreV.push_back(v);
                j++;
            }
        }
    }
    
    for (std::vector<vertex>::iterator it = m_MoreV.begin() ; it != m_MoreV.end(); ++it)
        pV.push_back(&(*it));
    
    return;
}
